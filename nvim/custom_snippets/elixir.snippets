global !p
def file_name_to_module_name(file_name):
	snake_name = os.path.splitext(snake_case)[0].replace(".", "_")
	return ''.join(x.capitalize() or '_' for x in snake_name.split('_'))
endglobal

snippet do
do
	${0:${VISUAL}}
end
endsnippet

snippet put "IO.puts"
IO.puts "${0}"
endsnippet

snippet ins "IO.inspect"
IO.inspect ${0}
endsnippet

snippet insl "IO.inspect with label"
IO.inspect(${0}label: "${1:label}")
endsnippet

snippet if "if .. do .. end"
if ${1} do
	${0:${VISUAL}}
end
endsnippet

snippet if: "if .. do: .."
if ${1:condition}, do: ${0}
endsnippet

snippet ife "if .. do .. else .. end"
if ${1:condition} do
	${2:${VISUAL}}
else
	${0}
end
endsnippet

snippet ife: "if .. do: .. else:"
if ${1:condition}, do: ${2}, else: ${0}
endsnippet

snippet unless "unless .. do .. end"
unless ${1} do
	${0:${VISUAL}}
end
endsnippet

snippet unless: "unless .. do: .."
unless ${1:condition}, do: ${0}
endsnippet

snippet unlesse "unless .. do .. else .. end"
unless ${1:condition} do
	${2:${VISUAL}}
else
	${0}
end
endsnippet

snippet unlesse: "unless .. do: .. else:"
unless ${1:condition}, do: ${2}, else: ${0}
endsnippet

snippet cond "cond do ... end"
cond do
	${1} ->
		${0:${VISUAL}}
end
endsnippet

snippet case "case do ... end"
case ${1} do
	${2} ->
		${0}
end
endsnippet

snippet for "for i <- items do ... end"
for ${1:item} <- ${2:items} do
	${0}
end
endsnippet

snippet for: "for: i <- items, do: ..."
for ${1:item} <- ${2:items}, do: ${0}
endsnippet

snippet fori "for: i <- items, into: ... do ... end"
for ${1:item} <- ${2:items}, into: ${3} do
	${0}
end
endsnippet

snippet wi "with match <- value do ... end"
with ${1:item} <- ${2:items} do
	${0}
end
endsnippet

snippet wie "with match <- value do ... else ... end"
with ${1:item} <- ${2:items} do
	${3}
else
	${4} ->
		${0}
end
endsnippet

snippet sp "@spec"
@spec ${1:name}(${2:args}) :: ${3:returns}
endsnippet

snippet op "@opaque"
@opaque ${1:type_name} :: ${2:type}
endsnippet

snippet ty "@type"
@type ${1:type_name} :: ${2:type}
endsnippet

snippet typ "@typep"
@typep ${1:type_name} :: ${2:type}
endsnippet

snippet cb "@callback"
@callback ${1:name}(${2:args}) :: ${3:returns}
endsnippet

snippet df "def name, do: ..."
def ${1:name}, do: ${2}
endsnippet

snippet def "def name do ... end"
def ${1:name} do
	${0}
end
endsnippet

snippet defd "@doc + def name do ... end"
@doc """
${1:doc string}
"""
def ${2:name} do
	${0}
end
endsnippet

snippet defsd "@doc + @spec + def name do ... end"
@doc """
${1:doc string}
"""
@spec ${2:name} :: ${3:no_return}
def $2 do
	${0}
end
endsnippet

snippet defim "defimpl"
defimpl ${1:protocol_name}, for: ${2:data_type} do
	${0}
end
endsnippet

snippet defma "defmacro name do ... end"
defmacro ${1:name} do
	${0}
end
endsnippet

snippet defmo "defmodule App.Name do ... end"
defmodule ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} do
	${0}
end
endsnippet

snippet dfp: "defp name, do: ..."
defp ${1:name}, do: ${2}
endsnippet

snippet defp "defp name do ... end"
defp ${1:name} do
	${0}
end
endsnippet

snippet defpr "defprotocol"
defprotocol ${1:name}, [${0:function}]
endsnippet

snippet defr "defrecord"
defrecord ${1:record_name}, ${0:fields}
endsnippet

snippet doc "@doc"
@doc """
${0}
"""
endsnippet

snippet im "@imple true"
@impl true
endsnippet

snippet docf "@doc false"
@doc false
endsnippet

snippet fn "Anon function. fn a -> ... end"
fn ${1:args} -> ${0} end
endsnippet

snippet mdoc "@moduledoc"
@moduledoc """
${0}
"""
endsnippet

snippet mdocf "@moduledoc false"
@moduledoc false
endsnippet

snippet rec "receive do ... end"
receive do
	${1} ->
		${0}
end
endsnippet

snippet req "require Module"
require ${0:Logger}
endsnippet

snippet imp "import Module"
import ${0:module_name}
endsnippet

snippet ali "alias Module"
alias ${0:module_name}
endsnippet

snippet test "Text block"
test "${1:test name}" do
	${0}
end
endsnippet

snippet testc "Test block with context"
test "${1:test_name}", ctx do
	${0}
end
endsnippet

snippet testa "Test block with args"
test "${1:test_name}", %{${2:arg: arg}} do
	${0}
end
endsnippet

snippet des "Describe block"
describe "${1:test group subject}" do
	${0}
end
endsnippet

snippet exunit "Define test module"
defmodule Gringotts.${1:`!p snip.rv = file_name_to_module_name(snip.fn)`} do
	use ExUnit.Case, async: true

	${0}
end
endsnippet

snippet try "try .. rescue .. end"
try do
	${1:${VISUAL}}
rescue
	${2} -> ${0}
end
endsnippet

snippet pry "IEx.pry"
require IEx; IEx.pry
${0}
endsnippet

snippet qu "quote do ... end"
quote do
	${1}
end
endsnippet

snippet beh "Define a behaviour"
@behaviour ${1:Mix.Task}
${0}
endsnippet

snippet p "|> value"
|> ${0}
endsnippet

snippet >e "pipe to each"
|> Enum.each(fn ${1} -> ${0} end)
endsnippet

snippet >m "pipe to map"
|> Enum.map(fn ${1} -> ${0} end)
endsnippet

snippet >f "pipe to filter"
|> Enum.filter(fn ${1} -> ${0} end)
endsnippet

snippet >r "pipe to reduce"
|> Enum.reduce(${1:acc}, fn ${2}, ${3:acc} -> ${0} end)
endsnippet

snippet >i "pipe to inspect"
|> IO.inspect
endsnippet

snippet >il "pipe to inspect with label"
|> IO.inspect(label: "${1:label}")
endsnippet

snippet cs "child_spec"
@doc false
def child_spec(${1:_opts}) do
%{
	id: __MODULE__,
	start: {__MODULE__, :start_link, ${2:[]}},
	restart: ${3::permanent},
	shutdown: ${4:5000},
	type: ${5::worker}
}
end
endsnippet

snippet genserver "basic genserver structure"
use GenServer

@doc false
def start_link do
	GenServer.start_link(__MODULE__, ${1:Map.new})
end

@impl true
def init(state) do
	{:ok, state}
end
endsnippet

snippet genserver: "basic genserver structure"
use GenServer

@doc false
def start_link, do: GenServer.start_link(__MODULE__, ${1:Map.new})

@impl true
def init(state), do: {:ok, state}
endsnippet

snippet impl "@impl true + def name do ... end"
@impl true
def ${1:name} do
	${0}
end
endsnippet

snippet broadway "Set up the boilerplate for a Broadway subscriber"
defmodule Gringotts.Async.${1:`!p snip.rv = file_name_to_module_name(snip.fn)`} do
	use Broadway

	@queue "gringotts.${2:queue_name}"
	@routing_key "gringotts.${3:entity.changed}"
	@exchange "gringotts"

	def start_link(_opts) do
		Broadway.start_link(__MODULE__,
			name: __MODULE__,
			producers: [
				default: [
					module:
						{BroadwayRabbitMQ.Producer,
						queue: @queue,
						declare: [durable: true],
						bindings: [
							{@exchange, [routing_key: @routing_key]}
						],
						connection: rabbit_url(),
						qos: [
							prefetch_count: 5
						]},
					stages: 1
				]
			],
			processors: [
				default: [
					stages: 1
				]
			]
		)
	end

	defp rabbit_url do
		Application.get_env(:gringotts, :rabbit_url)
	end

	@impl true
	def handle_message(_processor, message, _context) do
		${3:Logger.info(["[$1]Received message: ", inspect(message)])}
	end
end
endsnippet
